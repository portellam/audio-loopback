#!/bin/bash/env bash

#
# Filename:       /usr/local/bin/create-audio-loopback
# Description:    Create audio loopback device(s). Bind audio input(s) to first parsed active output.
#                 If no active output is found, bind to first inactive output.
#                 If no output is found, fail.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        1.0.0
#

# <traps>
  trap 'catch_error' SIGINT SIGTERM ERR
  trap 'catch_exit' EXIT
# </traps>

# <params>
  readonly SCRIPT_NAME="$( basename "${0}" )"
  readonly PREFIX_PROMPT="${SCRIPT_NAME}: "

  # <summary>Preserve internal field separator</summary>
    readonly SAVEIFS="${IFS}"
    IFS=$'\n'

  # <summary>
  # Color coding
  # Reference URL: 'https://www.shellhacks.com/bash-colors'
  # </summary>
    readonly SET_COLOR_GREEN='\033[0;32m'
    readonly SET_COLOR_RED='\033[0;31m'
    readonly SET_COLOR_YELLOW='\033[0;33m'
    readonly RESET_COLOR='\033[0m'

  # <summary>Append output</summary>
    readonly PREFIX_ERROR="${SET_COLOR_RED}An error occurred:${RESET_COLOR} "
    readonly PREFIX_FAIL="${SET_COLOR_RED}Failure:${RESET_COLOR} "
    readonly PREFIX_PASS="${SET_COLOR_GREEN}Success:${RESET_COLOR} "

  AUDIO_INPUT_LIST=( )
  ACTIVE_AUDIO_OUTPUT_LIST=( )
  INACTIVE_AUDIO_OUTPUT_LIST=( )
  VIRTUAL_BRIDGES_LIST=( )
# </params>

# <functions>
  function main
  {
    get_lists

    if ! create_all_virtual_audio_bridges \
      || ! bind_all_audio_outputs_to_all_bridges \
      || ! do_any_virtual_audio_bridges_exist; then
      exit 1
    fi

    exit 0
  }

  # <summary>Getters</summary>
    function get_lists
    {
      AUDIO_INPUT_LIST="$( pactl list short sources | grep --extended-regexp --ignore-case 'analog' | grep --extended-regexp --ignore-case 'input' )"
      ACTIVE_AUDIO_OUTPUT_LIST="$( pactl list short sinks | grep 'RUNNING' )"
      INACTIVE_AUDIO_OUTPUT_LIST="$( pactl list short sinks | grep --invert-match 'RUNNING' )"
    }

  # <summary>Clean-up</summary>
    function reset_ifs
    {
      IFS="${SAVEIFS}"
    }

  # <summary>Data-type validation</summary>
    function is_enum
    {
      local -n this_enum="${1}"

      if ! [[ "${#this_enum[@]}" -gt 0 ]]; then
        print_to_error_log "Invalid enum."
        return 1
      fi
    }

    function is_enum_not_empty
    {
      is_enum "${1}" || return 1
      local -n this_enum="${1}"

      for value in "${this_enum[@]}"; do
        if is_string "${value}" &> /dev/null; then
          return 0
        fi
      done

      print_to_error_log "Empty enum."
      return 1
    }

    function is_string
    {
      if [[ "${1}" == "" ]]; then
        print_to_error_log "Empty string."
        return 1
      fi
    }

  # <summary>Handlers</summary>
    function catch_error {
      exit 255
    }

    function catch_exit {
      print_pass_or_fail
      reset_ifs
    }

    function is_user_superuser
    {
      if [[ $( whoami ) != "root" ]]; then
        print_to_error_log "User is not sudo or root."
        return 1
      fi
    }

  # <summary>Loggers</summary>
    function print_to_error_log
    {
      echo -e "${PREFIX_PROMPT}${PREFIX_ERROR}${1}" >&2
    }

    function print_to_output_log
    {
      echo -e "${PREFIX_PROMPT}${1}" >&1
    }

    function print_pass_or_fail
    {
      if [[ "${?}" -ne 0 ]]; then
        print_to_output_log "${PREFIX_FAIL}Setup incomplete."
        return 1
      fi

      print_to_output_log "${PREFIX_PASS}Setup complete."
    }

  # <summary>Bind to bridge logic</summary>
    function bind_all_audio_outputs_to_all_bridges
    {
      local -a audio_output_list=""

      if ! is_enum_not_empty "ACTIVE_AUDIO_OUTPUT_LIST" &> /dev/null \
        && ! is_enum_not_empty "INACTIVE_AUDIO_OUTPUT_SOURCES_LIST" &> /dev/null; then
        print_to_error_log "No audio outputs."
        return 1
      fi

      if ! is_enum_not_empty "ACTIVE_AUDIO_OUTPUT_LIST" &> /dev/null; then
        audio_output_list="INACTIVE_AUDIO_OUTPUT_SOURCES_LIST"
        print_to_error_log "No active audio outputs. Parsing inactive audio outputs."
      else
        audio_output_list="ACTIVE_AUDIO_OUTPUT_LIST"
        print_to_output_log "Parsing active audio outputs."
      fi

      for audio_output in "${audio_output_list[@]}"; do
        if ! is_string "${audio_output}" &> /dev/null; then
          continue
        fi

        local -r audio_output_name="$( echo "${audio_output}" | awk '{print $2}' )"
        bind_this_audio_output_to_all_bridges "${audio_output_name}"
      done
    }

    function bind_this_audio_output_to_all_bridges
    {
      local -r this_audio_output_name="${1}"

      for virtual_bridge in "${VIRTUAL_BRIDGES_LIST[@]}"; do
        bind_this_audio_output_to_this_bridge "${this_audio_output_name}" "${virtual_bridge}" || return 1
      done
    }

    function bind_this_audio_output_to_this_bridge
    {
      local -r this_audio_output_name="${1}"
      local -r this_virtual_bridge="${2}"

      if ! pactl load-module module-loopback source="${this_audio_output_name}" sink="${this_virtual_bridge}"; then
        print_to_error_log "Failed to bind audio output '${this_audio_output_name}' to virtual bridge '${this_virtual_bridge}'."
        return 1
      fi

      print_to_output_log "Binded audio output '${this_audio_output_name}' to virtual bridge '${this_virtual_bridge}'."
    }

  # <summary>Create bridge logic</summary>
    function create_all_virtual_audio_bridges
    {
      for audio_input in "${AUDIO_INPUT_LIST[@]}"; do
        local -i audio_input_index="$( echo "${audio_input}" | awk '{print $1}' )"
        local audio_input_name="$( echo "${audio_input}" | awk '{print $2}' )"
        create_this_virtual_audio_bridge "${audio_input_index}" "${audio_input_name}" || return 1
      done
    }

    function create_this_virtual_audio_bridge
    {
      local -ir this_audio_input_index="${1}"
      local -r this_audio_input_name="${2}"
      local -r virtual_bridge_name="input_${this_audio_input_index}"

      if ! pactl load-module module-virtual-sink sink_name="${virtual_bridge_name}"; then
        print_to_error_log "Failed to create virtual audio bridge for '${this_audio_input_name}'."
        return 1
      fi

      add_virtual_audio_bridge_to_list "${virtual_bridge_name}"
      print_to_output_log "Created virtual audio bridge for '${this_audio_input_name}'."
    }

  function add_virtual_audio_bridge_to_list
  {
    local -r virtual_bridge="${1}"
    VIRTUAL_BRIDGES_LIST+=( "${virtual_bridge}" )
  }

  function do_any_virtual_audio_bridges_exist
  {
    if ! is_enum_not_empty "VIRTUAL_BRIDGES_LIST" &> /dev/null; then
      print_to_error_log "No virtual audio bridges found."
      return 1
    fi
  }
# </functions>

# <code>
  main
# </code